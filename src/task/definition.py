from dataclasses import dataclass, field
from typing import Any, Callable, Dict, Optional


@dataclass
class TaskResult:
    """Result of a task execution."""

    # Whether the task use a tool for execution
    use_tool: bool = False
    # Output of the task execution
    output: Optional[str] = None
    # Error message if the task failed
    error: Optional[str] = None


@dataclass
class Task:
    """Base class representing a task that needs to be performed by an agent.

    A task encapsulates the work that needs to be done and tracks the result of its execution.
    """

    # Name of the task
    name: str
    # Background information of the task, will be used as system message for the agent
    background: Optional[str]
    # Description of the task, will be used as query for the agent
    description: str = None
    # Model to use for this task, if not provided, the default model will be used
    model: Optional[str] = None
    # Whether to allow to use a tool for this task
    use_tool: bool = False
    # Configuration for the agent to use for this task
    agent_config: Optional[Dict[str, Any]] = None
    # Result of the task execution
    result: TaskResult = field(default_factory=TaskResult)
    # Status of the task, may be: pending, in_progress, completed, failed
    status: str = field(default="pending", init=False)
    # Path to save the artifact generated by the task
    artifact_path: Optional[str] = None

    # Optional callbacks
    pre_execution: Optional[Callable] = None
    post_execution: Optional[Callable] = None

    def __post_init__(self):
        """Validate task attributes after initialization."""
        if not self.name:
            raise ValueError("Task must have a name")
        if not self.description:
            raise ValueError("Task must have a description")

    def set_result(self, result: Dict[str, Any]) -> None:
        """Set the result of the task execution."""
        self.result = result
        self.status = "completed"

    def set_failed(self, error: Optional[str] = None) -> None:
        """Mark the task as failed with optional error information."""
        self.status = "failed"
        self.result.error = error or "<Task failed for unknown reason>"

    def is_complete(self) -> bool:
        """Check if the task is completed."""
        return self.status == "completed"

    def is_failed(self) -> bool:
        """Check if the task has failed."""
        return self.status == "failed"

    def __str__(self) -> str:
        """String representation of the task."""
        return f"Task({self.name}, status={self.status})"

    @classmethod
    def from_dict(cls, task_dict: Dict[str, Any]) -> "Task":
        """Create a Task instance from a dictionary."""
        return cls(**task_dict)
